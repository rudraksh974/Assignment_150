## Number of Provinces
    class Solution {
        public int findCircleNum(int[][] isConnected) {
            int n = isConnected.length;
            boolean[] visited = new boolean[n];
            int count=0;

            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    traverse(isConnected, visited, i, n);
                    count++;
                }
            }

            return provinces;
        }

        private void traverse(int[][] isConnected, boolean[] visited, int i, int n) {
            visited[i]=true;
            for (int j=0; j<n;j++) {
                if (isConnected[i][j] == 1 && !visited[j]) {
                    traverse(isConnected, visited, j, n);
                }
            }
        }
    }

## Flood fill Algorithm
    class Solution {
        public int[][] floodFill(int[][] image, int sr, int sc, int color) {
            int n = image.length;
            int m = image[0].length;
            boolean[][] visited = new boolean[n][m];
            int a = image[sr][sc];
            traverse(image,sr,sc,color,n,m,visited,a);
            return image;
        }
        void traverse(int[][] arr,int i ,int j,int color,int n,int m, boolean[][] visited,int a){
            Queue<int[]> que = new LinkedList<>();
            que.add(new int[]{i,j});
            visited[i][j]=true;
            arr[i][j]=color;
            int dc[]={1,0,-1,0};
            int dr[]={0,1,0,-1};
            while(!que.isEmpty()){
                int[] curr=que.poll();
                int curr_r=curr[0];
                int curr_c=curr[1];
                for(int k=0 ;k<dr.length ; k++){
                        int nr = curr_r+dr[k];
                        int nc = curr_c+dc[k];
                        if(isvalid(visited,arr,nr,nc,n,m,a)){
                            arr[nr][nc] = color;
                            visited[nr][nc]=true;
                            que.add(new int[]{nr,nc});
                        }
                }
            }
        }

        static boolean isvalid(boolean[][] visited,int[][] arr ,int i,int j,int n ,int m,int a){
            if(i>=0 && i<n && j>=0 && j<m && !visited[i][j] && arr[i][j]==a){
                return true;
            }
            return false;
        }
    }
## Minimum Cost Path

## Replace O's with X's
    class Solution {
        `public void solve(char[][] grid) {
            int n = grid.length;
            int m = grid[0].length;
            boolean[][] visited = new boolean[n][m];
            int count=0;
            for(int j=0;j<m;j++){
                if(visited[0][j]==false && grid[0][j]=='O'){
                    traverse(grid,0,j,visited,n,m);
                }
            } 
            for(int j=0;j<m;j++){
                if(visited[n-1][j]==false && grid[n-1][j]=='O'){
                    traverse(grid,n-1,j,visited,n,m);  
                }
            } 
            for(int j=0;j<n;j++){
                if(visited[j][0]==false && grid[j][0]=='O'){
                    traverse(grid,j,0,visited,n,m);
                }
            } 
            for(int j=0;j<n;j++){
                if(visited[j][m-1]==false && grid[j][m-1]=='O'){
                    traverse(grid,j,m-1,visited,n,m);  
                }
            }   
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(!visited[i][j] && grid[i][j]=='O'){
                        grid[i][j]='X';
                    }
                }
            }
        }

        public void traverse(char[][] grid,int i,int j,boolean[][] visited,int n,int m){
            Queue<int[]> que = new LinkedList<>();
            que.add(new int[]{i,j});
            visited[i][j] = true;
            int[] row={0,1,0,-1};
            int[] col={1,0,-1,0};
            while(!que.isEmpty()){
                int[] curr = que.poll();
                int r = curr[0];
                int c = curr[1];
                for(int k=0;k<4;k++){
                    int nr = r+row[k];
                    int nc = c+col[k];
                    if(nr>=0 && nc>=0 && nr<n && nc<m && !visited[nr][nc] && grid[nr][nc]=='O'){
                        que.add(new int[]{nr,nc});
                        visited[nr][nc]=true;
                    }
                }
            }
        }
    }

## Number of Distinct Islands

    
    class Solution {
        int countDistinctIslands(int[][] arr) {
            int n=arr.length;
            int m=arr[0].length;
            boolean[][] visited = new boolean[n][m];
            HashSet<ArrayList> hs = new HashSet<>();
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(!visited[i][j] && arr[i][j]==1){
                        ArrayList<String> ans = new ArrayList<>();
                        bfs(visited,i,j,n,m,arr,ans);
                        hs.add(ans);
                    }
                }
            }
            return hs.size();
        }

        static void bfs(boolean[][] visited,int sr,int sc , int n,int m,int[][] arr,ArrayList<String> ans){
            Queue<int[]> q =new LinkedList<>();
            visited[sr][sc]=true;
            q.add(new int[]{sr,sc});
            ans.add(toString(0,0)); 
            int dc[]={1,0,-1,0};
            int dr[]={0,1,0,-1};
            while(!q.isEmpty()){
                int[] curr=q.poll();
                int curr_r=curr[0];
                int curr_c=curr[1];
                for(int i=0 ;i<dr.length ; i++){
                        int nr = curr_r+dr[i];
                        int nc = curr_c+dc[i];
                        if(isValid(visited,arr,nr,nc,n,m)){
                            visited[nr][nc]=true;
                            ans.add(toString(sr - nr, sc - nc)); 
                            q.add(new int[]{nr,nc});
                        }
                }
            }
        }
        static String toString(int r ,int c){
            return Integer.toString(r)+" "+Integer.toString(c);
        }
        static boolean isValid(boolean[][] visited,int[][] arr ,int i,int j,int n ,int m){
            if(i>=0 && i<n && j>=0 && j<m && !visited[i][j] && arr[i][j]==1){
                return true;
            }
            return false;
        }
    }