## Number of Provinces
    class Solution {
        public int findCircleNum(int[][] isConnected) {
            int n = isConnected.length;
            boolean[] visited = new boolean[n];
            int count=0;

            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    traverse(isConnected, visited, i, n);
                    count++;
                }
            }

            return provinces;
        }

        private void traverse(int[][] isConnected, boolean[] visited, int i, int n) {
            visited[i]=true;
            for (int j=0; j<n;j++) {
                if (isConnected[i][j] == 1 && !visited[j]) {
                    traverse(isConnected, visited, j, n);
                }
            }
        }
    }

## Flood fill Algorithm
    class Solution {
        public int[][] floodFill(int[][] image, int sr, int sc, int color) {
            int n = image.length;
            int m = image[0].length;
            boolean[][] visited = new boolean[n][m];
            int a = image[sr][sc];
            traverse(image,sr,sc,color,n,m,visited,a);
            return image;
        }
        void traverse(int[][] arr,int i ,int j,int color,int n,int m, boolean[][] visited,int a){
            Queue<int[]> que = new LinkedList<>();
            que.add(new int[]{i,j});
            visited[i][j]=true;
            arr[i][j]=color;
            int dc[]={1,0,-1,0};
            int dr[]={0,1,0,-1};
            while(!que.isEmpty()){
                int[] curr=que.poll();
                int curr_r=curr[0];
                int curr_c=curr[1];
                for(int k=0 ;k<dr.length ; k++){
                        int nr = curr_r+dr[k];
                        int nc = curr_c+dc[k];
                        if(isvalid(visited,arr,nr,nc,n,m,a)){
                            arr[nr][nc] = color;
                            visited[nr][nc]=true;
                            que.add(new int[]{nr,nc});
                        }
                }
            }
        }

        static boolean isvalid(boolean[][] visited,int[][] arr ,int i,int j,int n ,int m,int a){
            if(i>=0 && i<n && j>=0 && j<m && !visited[i][j] && arr[i][j]==a){
                return true;
            }
            return false;
        }
    }
## Minimum Cost Path

## Replace O's with X's
    class Solution {
        `public void solve(char[][] grid) {
            int n = grid.length;
            int m = grid[0].length;
            boolean[][] visited = new boolean[n][m];
            int count=0;
            for(int j=0;j<m;j++){
                if(visited[0][j]==false && grid[0][j]=='O'){
                    traverse(grid,0,j,visited,n,m);
                }
            } 
            for(int j=0;j<m;j++){
                if(visited[n-1][j]==false && grid[n-1][j]=='O'){
                    traverse(grid,n-1,j,visited,n,m);  
                }
            } 
            for(int j=0;j<n;j++){
                if(visited[j][0]==false && grid[j][0]=='O'){
                    traverse(grid,j,0,visited,n,m);
                }
            } 
            for(int j=0;j<n;j++){
                if(visited[j][m-1]==false && grid[j][m-1]=='O'){
                    traverse(grid,j,m-1,visited,n,m);  
                }
            }   
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(!visited[i][j] && grid[i][j]=='O'){
                        grid[i][j]='X';
                    }
                }
            }
        }

        public void traverse(char[][] grid,int i,int j,boolean[][] visited,int n,int m){
            Queue<int[]> que = new LinkedList<>();
            que.add(new int[]{i,j});
            visited[i][j] = true;
            int[] row={0,1,0,-1};
            int[] col={1,0,-1,0};
            while(!que.isEmpty()){
                int[] curr = que.poll();
                int r = curr[0];
                int c = curr[1];
                for(int k=0;k<4;k++){
                    int nr = r+row[k];
                    int nc = c+col[k];
                    if(nr>=0 && nc>=0 && nr<n && nc<m && !visited[nr][nc] && grid[nr][nc]=='O'){
                        que.add(new int[]{nr,nc});
                        visited[nr][nc]=true;
                    }
                }
            }
        }
    }

## Number of Distinct Islands

    