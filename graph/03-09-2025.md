## BSF of Graph

    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {

        Queue<Integer> que = new LinkedList<>();
        que.add(0);
        ArrayList<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[adj.size()];
        visited[0] =true;
        while(!que.isEmpty()){
            int node = que.poll();
            list.add(node);

            for(int i=0;i<adj.get(node).size();i++){
                if(!visited[adj.get(node).get(i)]){
                    visited[adj.get(node).get(i)]=true;
                    que.add(adj.get(node).get(i));
                }
            }
        }
        return list;
    }

## DFS of Graph

    class Solution {
    // Function to return a list containing the DFS traversal of the graph.
        public ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> adj) {
            
            ArrayList<Integer> ans = new ArrayList<>();
            boolean[] visited = new boolean[adj.size()];
            traverse(adj,ans,visited,0,-1);
            return ans;
        }
        void traverse(ArrayList<ArrayList<Integer>> adj,ArrayList<Integer> ans,boolean[] visited,int curr,int par){
            
            ans.add(curr);
            // System.out.println(par+"-->"+curr); // Parent call
            visited[curr]=true;
            for(int i=0;i<adj.get(curr).size();i++){
                int child = adj.get(curr).get(i);
                if(visited[child]==false){
                    traverse(adj,ans,visited,child,curr);
                }
            }
        }
    }
## Shortest path from 1 to n 
    class Solution {
        int ans;
        public int minStep(int n) {
            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
            for(int i = 0;i<n+1 ;i++){
                adj.add(new ArrayList<>());
            }
            for(int i=1;i<=n;i++){
                if(i+1<=n){
                    adj.get(i).add(i+1);
                }
                if(i*3<=n){
                    adj.get(i).add(i*3);
                }
            }
            ans=n+1;
            boolean[] visited = new boolean[adj.size()];
            traverse(adj,1,visited,n,0);
            return ans;
        }
        public void traverse(ArrayList<ArrayList<Integer>> adj,int curr, boolean[] visited ,int tar,int count){
            if(curr==tar){
                ans=Math.min(ans,count);
                return;
            }
            visited[curr]=true;
            for(int i=0;i<adj.get(curr).size();i++){
                if(!visited[adj.get(curr).get(i)] && count<ans){
                    traverse(adj,adj.get(curr).get(i),visited,tar,count+1);
                }
            }
            visited[curr]=false;
        }
    }
## Find the number of islands 

## Rotten Oranges
