## BSF of Graph

    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {

        Queue<Integer> que = new LinkedList<>();
        que.add(0);
        ArrayList<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[adj.size()];
        visited[0] =true;
        while(!que.isEmpty()){
            int node = que.poll();
            list.add(node);

            for(int i=0;i<adj.get(node).size();i++){
                if(!visited[adj.get(node).get(i)]){
                    visited[adj.get(node).get(i)]=true;
                    que.add(adj.get(node).get(i));
                }
            }
        }
        return list;
    }

## DFS of Graph

    class Solution {
    // Function to return a list containing the DFS traversal of the graph.
        public ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> adj) {
            
            ArrayList<Integer> ans = new ArrayList<>();
            boolean[] visited = new boolean[adj.size()];
            traverse(adj,ans,visited,0,-1);
            return ans;
        }
        void traverse(ArrayList<ArrayList<Integer>> adj,ArrayList<Integer> ans,boolean[] visited,int curr,int par){
            
            ans.add(curr);
            // System.out.println(par+"-->"+curr); // Parent call
            visited[curr]=true;
            for(int i=0;i<adj.get(curr).size();i++){
                int child = adj.get(curr).get(i);
                if(visited[child]==false){
                    traverse(adj,ans,visited,child,curr);
                }
            }
        }
    }
## Shortest path from 1 to n 
    class Solution {
        int ans;
        public int minStep(int n) {
            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
            for(int i = 0;i<n+1 ;i++){
                adj.add(new ArrayList<>());
            }
            for(int i=1;i<=n;i++){
                if(i+1<=n){
                    adj.get(i).add(i+1);
                }
                if(i*3<=n){
                    adj.get(i).add(i*3);
                }
            }
            ans=n+1;
            boolean[] visited = new boolean[adj.size()];
            traverse(adj,1,visited,n,0);
            return ans;
        }
        public void traverse(ArrayList<ArrayList<Integer>> adj,int curr, boolean[] visited ,int tar,int count){
            if(curr==tar){
                ans=Math.min(ans,count);
                return;
            }
            visited[curr]=true;
            for(int i=0;i<adj.get(curr).size();i++){
                if(!visited[adj.get(curr).get(i)] && count<ans){
                    traverse(adj,adj.get(curr).get(i),visited,tar,count+1);
                }
            }
            visited[curr]=false;
        }
    }
## Find the number of islands
    class Solution {
        public int countIslands(char[][] grid) {
            int n = grid.length;
            int m = grid[0].length;
            boolean[][] visited = new boolean[n][m];
            int count=0;
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(visited[i][j]==false && grid[i][j]=='L'){
                        traverse(grid,i,j,visited,n,m);
                        count++;   
                    }
                }
            }       
            return count;
        }
        
        public void traverse(char[][] grid,int i,int j,boolean[][] visited,int n,int m){
            Queue<int[]> que = new LinkedList<>();
            que.add(new int[]{i,j});
            visited[i][j] = true;
            int[] row={0,1,0,-1,1,-1,-1,1};
            int[] col={1,0,-1,0,1,1,-1,-1};
            while(!que.isEmpty()){
                int[] curr = que.poll();
                int r = curr[0];
                int c = curr[1];
                for(int k=0;k<8;k++){
                    int nr = r+row[k];
                    int nc = c+col[k];
                    if(nr>=0 && nc>=0 && nr<n && nc<m && !visited[nr][nc] && grid[nr][nc]=='L'){
                        que.add(new int[]{nr,nc});
                        visited[nr][nc]=true;
                    }
                }
            }
        }
    }

## Rotten Oranges
    class Solution { 
        public int orangesRotting(int[][] mat) {
            Queue<int[]> q = new LinkedList<>();
            int n = mat.length;
            int m = mat[0].length;
            int fr_o=0;
            boolean visited[][] = new boolean[n][m];
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(mat[i][j]==2){
                        q.add(new int[]{i,j,0});
                        visited[i][j]=true;
                    }
                    else if(mat[i][j]==1){
                        fr_o++;
                    }
                }
            }
            return bfs_mat(mat,n,m,visited,q,fr_o);
        }
        static boolean isValid(int n_r,int n_c,int rows,int cols,boolean visited[][],int[][] mat){
            if(n_r>=0 && n_r < rows && n_c >= 0 && n_c < cols && !visited[n_r][n_c] && mat[n_r][n_c]==1){
                return true;
            }
            return false;
        }

        static int bfs_mat(int[][] mat,int rows,int cols,boolean[][] visited,Queue<int[]> q,int fr_o) {
            int ans = 0;
            while (!q.isEmpty()) {
                int curr[] = q.poll();
                int curr_row = curr[0];
                int curr_col = curr[1];
                int time = curr[2];
                int dc[] = {1, 0, -1, 0};
                int dr[] = {0, 1, 0, -1};
                for (int i = 0; i < dr.length; i++) {
                    int nbr_row = curr_row + dr[i];
                    int nbr_col = curr_col + dc[i];
                    int ti = time+1;
                    if (isValid(nbr_row, nbr_col, rows, cols, visited, mat)) {
                        visited[nbr_row][nbr_col] = true;
                        mat[nbr_row][nbr_col]=2;
                        q.add(new int[]{nbr_row, nbr_col,ti});
                        fr_o--;
                    }
                    if(fr_o==0) ans = ti-1;
                }

            }
            if(fr_o<=0) return ans;
            return -1;
        }
    }
